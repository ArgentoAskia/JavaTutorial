package cn.argento.askia.chain.type2;

/**
 * 责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它将请求沿着处理链传递，
 * 直到链中的某个对象能够处理它。下面为你详细介绍：
 *
 * 基本结构
 *
 *
 * • Handler（抽象处理者）：定义一个处理请求的接口，通常包含一个 successor（后继者）属性，
 *   用于保持对下一个处理对象的引用。它还定义了一个处理请求的方法，一般也叫 handleRequest()，
 *   在该方法中会判断是否有后续处理者，如果有则将请求传递给下一个处理者。
 *
 * • ConcreteHandler（具体处理者）：实现了抽象处理者定义的接口，它拥有一个 successor 属性，
 *   用于设置链中的下一个处理者。在处理请求时，它会判断是否有后续处理者，如果有则将请求传递给下一个处理者，
 *   否则自己处理该请求。一个具体处理者对象并不一定要有后继者，当它没有后继者时，它将是链中的最后一个处理者。
 *
 * 工作原理
 * 当一个请求被发送到一个处理者对象时，该处理者会先判断自己是否能够处理该请求。
 * 如果可以处理，就处理该请求；如果不可以处理，就将请求传递给链中的下一个处理者。
 * 这个会过程一直持续下去，直到请求被某个处理者处理或者链中的所有处理者都无法处理该请求。
 *
 * 优点
 * • 降低耦合度：将请求的发送者和接收者解耦，发送者不需要知道请求会被哪个接收者处理，
 *             只需将请求发送到链中即可。接收者也不需要知道链的结构和顺序，只需关注自己的处理逻辑。
 * • 增强灵活性：可以动态地添加或修改处理者，也可以动态地改变链的结构，使得系统在运行时具有较高的灵活性。
 * • 增加新的请求处理类很方便：在不修改现有代码的基础上，可以很容易地增加新的请求处理类，符合开闭原则。
 *
 *
 * 缺点
 * • 不能保证请求一定被处理：由于一个请求没有明确的接收者，所以不能保证它一定会被处理，这可能导致请求在链中得不到处理。
 * • 可能导致循环调用：如果链的配置错误，可能会导致请求在链中循环调用，从而引发系统错误。
 * • 可能会增加系统复杂度：如果链中的处理者过多，或者处理逻辑过于复杂，可能会增加系统的复杂度，使得调试和维护变得困难。
 *
 * 应用场景
 * • 审批流程：如请假审批系统，一个员工的请假请求可能需要先经过主管审批，如果主管审批不通过，就结束流程；
 *           如果审批通过，再经过经理审批，依此类推，直到最终的审批者。
 *
 * • 拦截器链：在 Web 开发中，拦截器链可以对请求进行一系列的预处理和后处理，如身份验证、日志记录、请求参数校验等。
 *
 * • 事件处理：在 GUI 程序中，事件处理通常采用责任链模式，如窗口、面板、按钮等组件可以组成一个责任链，
 *           当用户触发某个事件时，事件会在链中传递，直到找到合适的处理者。
 */
public class Client {

    public static void main(String[] args) {
        Handler webHandler1 = new WebHandler1();
        Handler webHandler2 = new WebHandler2();
        Handler wenHandler3 = new WenHandler3();

        // 创建脸
        webHandler1.setSuccessor(webHandler2);
        webHandler2.setSuccessor(wenHandler3);

        webHandler1.handlerRequest(2);
    }
}
